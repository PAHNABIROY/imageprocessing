// 1. Select the folder containing the images
dir = getDirectory("Choose a directory");

// 2. Get list of .oib files in the folder
fileList = getFileList(dir);
oibFiles = newArray();
oibFileName = newArray();
j = 0;
for (i = 0; i < fileList.length; i++) {
    if (endsWith(fileList[i], ".oib")) {
        oibFileName[j++] = fileList[i];
        oibFiles = Array.concat(oibFiles, dir + fileList[i]);
    }
}

if (oibFiles.length == 0) {
    print("No .oib files found in the directory. Exiting.");
    exit();
}

// Function to get intensity along the perimeter of a circle with given radius
function getIntensityAlongPerimeter(radius) {
	selectWindow(fileName + " - C=0");
    nPoints = 100; // Number of points to sample along the perimeter
    angleStep = 2 * PI / nPoints;
    perimeterIntensities = newArray(nPoints);

    for (i = 0; i < nPoints; i++) {
        angle = i * angleStep;
        x = centroidX + radius * cos(angle);
        y = centroidY + radius * sin(angle);
        perimeterIntensities[i] = getPixel(x, y);
        
    }
    return perimeterIntensities;
}
// Initialize arrays to store results
allResults = newArray();


// Process each .oib file
for (f = 0; f < oibFiles.length ; f++) {
    filePath = oibFiles[f];
    fileName = oibFileName[f];
    print("Processing: " + fileName);
    open(filePath);

    // Adjust the name as needed to match the actual title of the transmission channel
    selectWindow(fileName + " - C=2");
    n=nSlices();

    // Ensure roundness is included in the measurements
    run("Set Measurements...", "area mean standard min centroid fit shape feret's integrated redirect=None decimal=3");

    // Get the calibration information
    getPixelSize(unit, pixelWidth, pixelHeight);

    // Initialize variables to track the largest object with required roundness
    largestArea = 0;
    bestSlice = -1;
    bestCentroidX = 0;
    bestCentroidY = 0;

    // Loop through each stack to find the largest object with roundness > 0.5
    for (i = 1; i <= nSlices(); i++) {
        setSlice(i);
        run("Duplicate...", "title=tempSlice" + i);
        selectWindow("tempSlice" + i);
        run("8-bit");
        setAutoThreshold("Default");

        // Refine the threshold to avoid background being selected as an object
        setOption("BlackBackground", true);
        run("Convert to Mask");
        run("Find Edges");

        // Analyze particles with a more stringent size filter
        run("Analyze Particles...", "size=100-5000 display clear summarize add");

        roiCount = roiManager("Count");

        if (roiCount > 0) {
            // Measure all ROIs and ensure correct measurements are recorded
            roiManager("Measure");

            // Get the number of ROIs and ensure correct measurements are used
            for (j = 0; j < roiCount; j++) {
                roiManager("Select", j);
                run("Measure");
                roundness = getResult("Round", j + roiCount + 1);
                area = getResult("Area", j + roiCount + 1);

                if (roundness > 0.5 && area > largestArea) {
                    largestArea = area;

                    bestSlice = i;
                    bestCentroidX = getResult("X", j + roiCount + 1);
                    bestCentroidY = getResult("Y", j + roiCount + 1);
                }
            }
        }
        close();
        roiManager("Reset");
    }

    // Check if a valid slice with the largest object was found
    if (bestSlice == -1 || largestArea < 5000) {
        // Open the first slice for user to draw an ROI
        setSlice(1);
        print("Draw an oval ROI on the first slice and click OK.");
        waitForUser("Draw an oval ROI on the first slice and click OK.");

        // Measure the user-drawn ROI
        run("Measure");
        largestArea = getResult("Area", nResults() - 1);
        bestCentroidX = getResult("X", nResults() - 1);
        bestCentroidY = getResult("Y", nResults() - 1);
        bestSlice = 1;
    }

    // Convert centroid coordinates from pixels to calibrated units
    calibratedCentroidX = bestCentroidX / pixelWidth;
    calibratedCentroidY = bestCentroidY / pixelHeight;

    // Calculate the new radius (20% of the area)
    newRadius = sqrt((0.50 * largestArea) / PI);

    // Print centroid and radius values for debugging
    print("File: " + filePath);
    print("Best Slice: " + bestSlice);
    print("Centroid X (calibrated): " + calibratedCentroidX);
    print("Centroid Y (calibrated): " + calibratedCentroidY);
    print("New Radius: " + newRadius);

    // Create the initial ROI based on the largest object found
    selectWindow(fileName + " - C=2");
    setSlice(bestSlice);

    // Ensure coordinates and radius are properly converted to integers for the ROI
    intCentroidX = round(calibratedCentroidX);
    intCentroidY = round(calibratedCentroidY);
    intNewRadius = round(newRadius);

    makeOval(intCentroidX - intNewRadius, intCentroidY - intNewRadius, intNewRadius * 2, intNewRadius * 2);
    
    radiusResults = newArray();
    intensityResults = newArray();

    // Set initial radius (assuming initial ROI is a circle)
    radius = newRadius; // Initial radius, adjust as needed
    smallestUnit = 1; // Smallest unit to decrement the radius, adjust as needed
    distanceBetweenStacks = 5; // Adjust this as per the actual z-spacing between slices
    
    // Loop to process different radii
    while (radius > sqrt(n)*distanceBetweenStacks) 
    {
    	
        totalIntensityForRadius = 0;
        currentRadius = radius;
        i=0;
        // Loop through each slice in reverse order
        selectWindow(fileName + " - C=0");
        
        for (slice = nSlices(); slice >= 1; slice--) {
            setSlice(slice);
            i++;
            run("8-bit");
            print(slice);
            // Get the centroid coordinates (modify this as per your specific needs)
            centroidX = intCentroidX; // Example: center of the image
            centroidY = intCentroidY; // Example: center of the image
            
            intensities = getIntensityAlongPerimeter(currentRadius);
            avgIntensity = Array.getStatistics(intensities,mean);
            
            print("mean:" + mean);
            totalIntensityForRadius=totalIntensityForRadius+mean;
            print(totalIntensityForRadius);
            print(currentRadius);
            makeOval(centroidX-currentRadius,centroidY-currentRadius,currentRadius*2,currentRadius*2 );
            // Calculate the new radius for the next slice
            if (slice > 1 && currentRadius>sqrt(n)*distanceBetweenStacks) {
                currentRadius = sqrt(currentRadius * currentRadius - i*distanceBetweenStacks * distanceBetweenStacks);
            }
            else {
            	break;
            	}
        }

        // Store results for this radius
        
        radiusResults = Array.concat(radiusResults, radius);
        intensityResults = Array.concat(intensityResults, totalIntensityForRadius);

        // Reduce the radius by the smallest unit for the next iteration
        print("radius"+radius);
        radius -= smallestUnit;
    
       radiiResult = newArray(fileName,radius,totalIntensityForRadius);
       allResults = Array.concat(allResults,radiiResult);
    }
    // Plot the results for this file
    Plot.create("Radius vs Intensity:", "Radius (pixels)", "Intensity", radiusResults, intensityResults);
    close();

}
    // Save the concatenated results to CSV
csvContent = "File,radius,Mean Intensity\n";
for (i = 0; i < allResults.length; i += 3) {
    csvContent += allResults[i] + "," + allResults[i + 1] + "," + allResults[i + 2] + "\n";
}

// Write the CSV content to a file
path = dir + "intensity_results123.csv";
File.saveString(csvContent, path);
print("Results saved to: " + path);
